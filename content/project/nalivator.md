+++
Banner = "/img/nalivator.png"
Categories = ["project"]
Description = "Робот-бармен на Raspberry Pi и Golang"
Tags = ["golang","raspberrypi"]
date = "2017-10-05T15:49:06+03:00"
title = "Робот-бармен NALIVATOR-9000"

+++

Кросс-пост [моей статьи на Хабрахабре](https://habrahabr.ru/post/327220/).
Пару лет назад я наткнулся на проект <a href="https://www.kickstarter.com/projects/partyrobotics/bartendro-a-cocktail-dispensing-robot">Bartendro</a> на Kickstarter. Мне понравилась идея, и я решил, что идеальное применение для моего недавно приобретенного Raspberry Pi найдено.
<!--more-->

Я прикинул какие детали понадобятся, и приступил к DIY реализации робота-бармена. Кратко расскажу что из этого получилось.

<h2>Hardware</h2>
Основной элемент всей конструкции, конечно - насосы. В оригинальном проекте Bartendro используются перистальтические насосы собственной разработки (кстати, весь проект доступен в <a href="https://github.com/partyrobotics/bartendro">github</a>).

Перистальтический насос - это такой насос который толкает по трубке её содержимое, как будто тюбик с пастой выдавливает. Соответственно, один конец опускаем в бутылку, а второй в стакан. Гифка с Википедии с принципом действия:

<img src="https://upload.wikimedia.org/wikipedia/commons/9/95/Peristaltic_pump.gif" alt="image" align="center"/>

Похожие на оригинальные из Bartendro насосы есть в продаже на <a href="https://ru.aliexpress.com/item/DC-12V-Peristaltic-Pump-with-1100ml-min-Flow-Rate-and-30psi-output-pressure/1096126424.html">Aliexpress</a>. Практика показала, что они хороши в эксплуатации, т.к. у них снимается передняя панель с трубкой - очень удобно мыть после застолья.

У Raspberry Pi на плате расположены GPIO разъемы. С помощью них посылаются или принимаются сигналы "1" или "0", 3,3В и 0В, соотвественно. В спецификации к насосу указано, что его рабочее напряжение - 12В, и "малиновых" 3.3В здесь будет мало. Поэтому для работы понадобится еще блок питания, а управлять им можно с помощью транзисторного переключателя. Итоговая схема выглядит так:

<img src="https://4te.me/img/scheme.png" width=360 height=378 align="center">

Для выбора транзистора надо чтобы напряжение коллектор-эммитер и максимальный ток коллектора у него был минимум в 1.5-2 раза выше необходимых. Я выбрал <a href="http://www.farnell.com/datasheets/56743.pdf">BDX33B</a>, у него напряжение коллектор-эмиттер - 80В, а максимальный ток коллектора - 10A, что с запасом хватит для насоса со стартовым током 2А и напряжением 12В. Для того чтобы открыть транзистор, на базе надо получить не больше 2.5В. Считаем делитель в каком-нибудь онлайн-калькуляторе - получаем R1=150 Ом, R2=300 Ом.

В качестве "свистелок" я добавил три светодиода, подключенных к трем другим GPIO пинам, которые будут обозначать работающий моторчик, а также понадобятся при визуализации синтезатора речи. На выходы GPIO можно повесить максимальную нагрузку 15 мА на пин, или 50 мА суммарно. Поэтому подключаю светодиоды через резисторы по 300 Ом, ток в этом случае будет ~4 мА на пин.

Теперь можно идти в ближайший магазин радиодеталей и пробовать собирать.

<h2>Software</h2>
Raspberry Pi вообще довольно медленная штука - например, Django, на котором я изначально хотел сделать веб-приложение, запускается несколько минут. Поэтому я решил отказаться от него в пользу чего-нибудь легковесного, а именно - Go. Он быстро компилируется, кросс-компиляция под linux-arm на моем ПК занимает около 20 секунд. На выходе получаем небольшого размера бинарник, который статически собран и несет внутри все зависимости. Его можно сразу rsync-ом копировать на raspberry pi и проверять. Очень удобно для таких небольших приложений. Параметры кросс-компилияции под linux-arm выглядят так:

{{< highlight console >}}
$ GOOS=linux GOARCH=arm GOARM=6 go build
{{< /highlight >}}
У разных версий Raspberry Pi разные версии ARM. Узнать свою версию можно в <i>/proc/cpuinfo</i>

Так как у насосов нет никаких датчиков объема налитого, но известна пропускная способность, то объем можно контролировать через время работы насоса. Эмперическим путем я выяснил - чтобы налить 100 миллилитров, надо насос держать включенным 30 секунд. Получается нужно написать приложение, которое по команде, по очереди включает насосы на определенное время. В данной реализации подразумевается, что Наливатор умеет делать только один коктейль, то есть у него есть только одна кнопка - "Налить".

Я сделал конфиг в котором описаны подключенные насосы и коктейль, который нужно наливать.

{{< highlight json >}}
{
  "cname": "санрайз",
  "pumps": [
    {
      "name": "Tequila",
      "pump_pin": 17,
      "led_pin": 23,
      "duration": 17
    },
    {
      "name": "Juice",
      "pump_pin": 22,
      "led_pin": 25,
      "duration": 49
    },
    {
      "name": "Grenadine",
      "pump_pin": 27,
      "led_pin": 24,
      "duration": 7
    }
  ]
}
{{< /highlight >}}
Этот конфиг читает Наливатор при запуске, и понимает какой пин на какое время нужно включать. Для работы с GPIO я использовал библиотеку <a href="https://github.com/nathan-osman/go-rpigpio">go-rpigpio</a>:

{{< highlight go >}}
  for _, v := range CurrentPumps.Pumps {
    log.Printf("Nalivaem %s ;duration = %v; GPIO = %v", v.Name, v.Duration, v.Pump_pin)
    //pump pin open
    p, err := rpi.OpenPin(v.Pump_pin, rpi.OUT)
    if err != nil {
      panic(err)
    }
    defer p.Close()

    //led pin open
    l, l_err := rpi.OpenPin(v.Led_pin, rpi.OUT)
    if l_err != nil {
      log.Printf("LED - Can't set LED pin to output")
    }
    defer  l.Close()

    // pump on
    p.Write(rpi.HIGH)

    //led on
    l.Write(rpi.HIGH)

    time.Sleep(time.Second * time.Duration(v.Duration))

    // pump off
    p.Write(rpi.LOW)

    //led off
    l.Write(rpi.LOW)
  }
}
{{< /highlight >}}
Весь код в гитхабе - https://github.com/fote/nalivator9000

Осталось добавить веб-интерфейс и все готово. Насчет корпуса я не стал заморачиваться и разместил все в икеевской коробке. В этот момент я понял, что дизайнера из меня не выйдет. В общем над внешним обликом еще стоит поработать.

Когда пришло время испытаний, я пригласил друзей провести нагрузочное тестирование, но перед их приходом понял, что веб-интерфейс это не совсем удобно - он не доступен из интернета, а подключаться к запароленной wi-fi сети, вбивать IP-адрес в браузере... слишком сложно. Тогда я добавил telegram-бота, который ждёт что ему напишут имя коктейля и наливает его. Я не буду описывать как создать бота, т.к. уже есть множество хороших статей на эту тему, в том числе и для Golang.

![Nalivator 9000 telegram bot](/img/nalivator2.png)

Также я решил добавить синтез речи, воспользовавшись <a href="https://tech.yandex.ru/speechkit/cloud/doc/guide/concepts/tts-overview-technology-docpage/">Yandex SpeechKit</a>. API этого сервиса очень прост, а лицензионное соглашение позволяет пользоваться им бесплатно в некоммерческих целях. Перед отправкой сообщения от telegram-бота, я прогоняю фразу через SpeechKit, в ответ получаю .wav-файл и воспроизвожу его через подключенный по 3.5mm-jack динамик.

<h2>Заключение</h2>
Тестирование Наливатора прошло успешно - тестировщики остались довольны и оставили много фичереквестов.

Напоследок видео работы:

За ваше здоровье!

<iframe width="560" height="315" src="https://www.youtube.com/embed/8zgrqq7ezRE" frameborder="0" allowfullscreen></iframe>

Оригинал:
https://habrahabr.ru/post/327220/
